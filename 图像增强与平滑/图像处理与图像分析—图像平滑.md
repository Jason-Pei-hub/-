# 图像处理与图像分析—图像增强与平滑（C语言）



> 我们将从基础出发使用C语言进行图像处理与分析，重点讨论图像增强和平滑技术。图像增强技术旨在通过增加对比度、亮度和整体清晰度来改善图像的视觉质量。另一方面，图像平滑方法则用于减少噪声并减少图像中的突变，使图像更加均匀和视觉上吸引人。
>
> 使用C语言作为实现方式是因为只有当你手敲一遍这些代码，你才会对这些方法有更加深刻的理解



---

我们在前两次的笔记中已经实现了图像处理的基本操作

分别是

* **图像每一个像素灰度值的读入**
* **图像灰度值直方图的显示**

今天的目标实际上也很小，我们的目标就是实现**图像增强**和**平滑**

我们先来看共同点，首先，不管是图像增强还是平滑，重点都在于对于像素内容的操作



我们来看第一次笔记中所写的代码

```c
void F1(uint8_t* pImg, int width, int height)
{
    uint8_t* pCur;
    uint8_t* pEnd;

    pEnd = pImg + width * height;
    for (pCur = pImg; pCur < pEnd; pCur++)
    {
        //*pCur = f(*pCur);
        printf("%d ", *pCur);  // 输出灰度值
    }
    return;
}
```

很明显，在我们前面执行读取操作的时候，就已经留了f函数可以对像素进行操作了

那我们的实现逻辑就是

```c
1. 首先读取图片数据，判断图片数据内容
    
2. 根据图片内容来处理像素
    
3. 打开处理后的灰度值直方图
    
4. 打开处理后的图片
    
5. 打开处理前的灰度值直方图
```

我们梳理一下还缺少的步骤

* 处理像素的函数

书上一共讲了两种办法，分别是

1. **灰度线性拉伸算法**
2. **直方图均衡化**

我们一个一个来尝试



## 灰度线性拉伸算法

我们先来看代码

```c
void LinearStretchDemo(BYTE* pGryImg, int width, int height, double k, double b)
{
    BYTE* pCur, * pEnd;
    for(pCur = pGryImg,pEnd = pGryImg + width + height;pCur < pEnd;)
        //这个地方书上是这么写的，我在下面还是写成了标准写法
        {
            *(pCur++) = LUT[ * pCur];
        }
    return;
}
```

总体上来看还是比较简单，我们来试着写成C语言版本

```c
void LinearStretchDemo(uint8_t* pGryImg, int width, int height, double k, double b) 
{
    uint8_t* pCur, * pEnd;
    for (pCur = pGryImg, pEnd = pGryImg + width * height; pCur < pEnd; pCur++) 
    {
        *pCur = LUT[*pCur];
    }
}
```

这个代码前面讲过好多了，这里就不再多讲了，有兴趣可以去看看C语言图像的读入那一篇笔记

但是这里面LUT是什么意思呢？

> LUT 是 Look-Up Table 的缩写，中文意思是查找表或者映射表。在图像处理中，LUT 是一种非常常见的技机，用于对图像进行颜色或灰度值的映射和调整。
>
> 具体来说，LUT 是一个数组或者表格，其中存储了输入值到输出值的对应关系。在图像处理中，通常用 LUT 来实现颜色校正、对比度调整、灰度拉伸等操作。例如，在灰度拉伸中，LUT 存储了原始灰度值到拉伸后的灰度值之间的映射关系。
>
> 使用 LUT 的好处在于，它可以提高图像处理的效率，并且允许我们通过简单的表格查询来实现复杂的颜色或灰度值调整。同时，LUT 也可以在不同的图像处理算法中重复使用，提高了算法的复用性和可维护性。
>
> 总而言之，LUT 是图像处理中非常有用的工具，它通过预先计算和存储输入值到输出值的映射关系，帮助我们快速、高效地对图像进行颜色和灰度值的调整。



**这么说不是很好理解，我们直接来看书上下一个算法**

> 这里我直接写成C语言版本

```c
void LinearStretchDemo(uint8_t* pGryImg, int width, int height, double k, double b)
{
    uint8_t* pCur, * pEnd;
    int LUT[256];    //因为只有[0,255]共256个灰度值
    
    //step1. 生成查找表
    for (int g = 0; g < 256; g++)
    {
        LUT[g] = max(0, min(255, k * g + b));
    }
    
    //step2. 进行变换
    for (pCur = pGryImg, pEnd = pGryImg + width * height; pCur < pEnd; pCur++)
        {
            *pCur = LUT[*pCur];
        }
    //step3. 结束
    return;
}
```

这段代码是一个实现灰度图像线性拉伸处理的函数 `LinearStretchDemo`。让我来逐步解释这段代码的具体实现：

1. `uint8_t* pCur, * pEnd;`：定义了两个指针变量，`pCur` 用于指向当前处理的像素值，`pEnd` 指向图像数据的末尾。
2. `int LUT[256];`：定义了一个大小为 256 的整型数组，用于存储灰度值的映射关系。
3. 生成查找表部分：
   - `for (int g = 0; g < 256; g++)`：遍历所有可能的灰度值（0 到 255）。
   - `LUT[g] = max(0, min(255, k * g + b));`：对于每个灰度值，根据线性拉伸的公式 `k * g + b` 计算新的灰度值，并确保其范围在 0 到 255 之间，以防止越界。
4. 进行变换部分：
   - `for (pCur = pGryImg, pEnd = pGryImg + width * height; pCur < pEnd; pCur++)`：遍历图像数据中的每个像素。
   - `*pCur = LUT[*pCur];`：使用查找表 `LUT` 将当前像素的灰度值映射为线性拉伸后的新灰度值。
5. 返回处理结果并结束函数。



## C语言展示图片

我们来试着运行一下这个函数，不过在此之前我们需要知道在C语言中如何通过灰度值查看图片

我们还是使用这个库

```c
#include <SDL.h>
```

那具体实现逻辑就变成了

```c
void displayImage(uint8_t* pImg, int width, int height) 
{
    SDL_Window *window = NULL;
    SDL_Renderer *renderer = NULL;
    SDL_Texture *texture = NULL;


    // 创建窗口
    window = SDL_CreateWindow("Image Output", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
                              width, height, SDL_WINDOW_SHOWN);


    renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_ACCELERATED);
    if (!renderer) {
        printf("Error creating renderer: %s\n", SDL_GetError());
        SDL_DestroyWindow(window);
        SDL_Quit();
        return;
    }

    // 创建纹理
    texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_ARGB8888, SDL_TEXTUREACCESS_STREAMING, width, height);


    // 填充图像数据到纹理
    SDL_UpdateTexture(texture, NULL, pImg, width * sizeof(uint8_t));

    // 渲染纹理到窗口
    SDL_RenderClear(renderer);
    SDL_RenderCopy(renderer, texture, NULL, NULL);
    SDL_RenderPresent(renderer);

    // 等待退出事件，防止一瞬间退出
    SDL_Event event;
    while (SDL_WaitEvent(&event)) {
        if (event.type == SDL_QUIT) {
            break;
        }
    }

    SDL_DestroyTexture(texture);
    SDL_DestroyRenderer(renderer);
    SDL_DestroyWindow(window);
    SDL_Quit();
    //清理资源
}
```

具体的实现和配置方法在上一篇笔记中有提到，我们直接来测试效果

![image-20240316191348355](https://gitee.com/jason_pei/typora-bed/raw/master/image/202403161913595.png)

可以看到和我们想的不太一样，再检查一遍代码

没有找到愿意，尝试改了很多遍，还是只能显示一部分，这个可能需要在学习学习

![image-20240316200757356](https://gitee.com/jason_pei/typora-bed/raw/master/image/202403162007400.png)

那我们只能用其他方式，也就是说重新读写一个图片

，但是在此之前，我们需要把主函数的部分 重新写一下，把图片的读取也封装为一个函数

```c
typedef struct {
    uint8_t* imageData;
    int width;
    int height;
} ImageData;

ImageData readImage(const char* filename) {
    ImageData imageData;

    FILE* file = fopen(filename, "rb");
    if (!file) {
        printf("无法打开文件：%s\n", filename);
        exit(1);
    }

    uint8_t bmpHeader[54];
    size_t bytesRead = fread(bmpHeader, 1, 54, file);

    int width = *(int*)&bmpHeader[18];   // 宽度信息位于偏移量为 18 的位置
    int height = *(int*)&bmpHeader[22];  // 高度信息位于偏移量为 22 的位置

    uint8_t* imageDataArray = (uint8_t*)malloc(width * height);
    if (!imageDataArray) {
        printf("内存分配失败\n");
        fclose(file);
        exit(1);
    }

    fseek(file, 54, SEEK_SET);  // 跳过 BMP 文件头

    bytesRead = fread(imageDataArray, 1, width * height, file);

    imageData.imageData = imageDataArray;
    imageData.width = width;
    imageData.height = height;

    fclose(file);

    return imageData;
}

```

**封装完成**

---

20240316 宣告失败——无法完成图片的处理和写入操作——需要继续努力